grammar UriTemplate

  rule uri_template
    uri_element more_elements:(uri_element)* {
      def value(env={})
		#raise more_elements.elements.inspect
        uri_element.value(env) << more_elements.elements.map{|el| el.value(env)}.join
      end
    }
  end
  
  rule uri_element
    expansion / uri_part
  end

  rule expansion
    '{' 
	c:(
		var
		/
		operator
	) 
	'}'
	 {
        def value(env = {})
            #c.elements.map{|el| if el.respond_to?(:value); el.value(env); else; el.interval.to_s + "<>"; end }.join
			if c.respond_to? :value
			  c.value(env)
			else
			  c.interval.to_s + "<>"
			end
        end
      } 
  end

  rule uri_part
    (alphanumeric+ / ':' / '/' / '.' / '?' / '&' / '=') {
          def value(env = {})
            text_value
          end
        }
  end
 
  rule arg
    (reserved / unreserved / pct_encoded)*
  end

  rule op
    (
    'opt' {
	      # If one or more of the variables are defined and non-empty then
	   	  # substitute the value of 'arg', otherwise substitute the empty string.
	      def exec
	        lambda do |env, arg, vars| 
			  if !env[vars].to_s.blank?
				"#{arg}"
			  else
			    ""
			  end
			end
	      end
	    }
    / 
    'neg' {
	  # If all of the variables are un-defined or empty then substitute the
	  # value of arg, otherwise substitute the empty string.
      def exec
        lambda do |env, arg, vars| 
		  if env[vars].to_s.blank?
			"#{arg}"
		  else
		    ""
		  end
		end
      end
    }
    / 
    'prefix' {
	  # The prefix operator MUST only have one variable in its expansion.  If
	  # the variable is defined and non-empty then substitute the value of
	  # arg followed by the value of the variable, otherwise substitute the
	  # empty string.
      def exec
        lambda do |env, prefix, vars| 
		  if env[vars]
			val = CGI.escape(env[vars])
			!val.blank? ? "#{prefix}#{val}" : ""
		  end
		end
      end
    } 
    / 
    'append' {
	  # The append operator MUST only have one variable in its expansion.  If
	  # the variable is defined and non-empty then substitute the value of
	  # the variable followed by the value of arg, otherwise substitute the
	  # empty string.
      def exec
        lambda do |env, append, vars| 
		  if env[vars]
			val = CGI.escape(env[vars])
			!val.blank? ? "#{val}#{append}" : ""
		  else
		    ''
		  end
		end
      end
    } 
    / 
    'join' {
	  # For each variable that is defined and non-empty create a keyvalue
	  # string that is the concatenation of the variable name, "=", and the
	  # variable value.  Concatenate more than one keyvalue string with
	  # intervening values of arg to create the substitution value.
	  def exec
        lambda do |env, joinop, vars| 
		  vars.split(',').map do |v|
		  	if env[v]
              "#{v}=#{CGI.escape(env[v])}"
		  	end
		  end.join(joinop)
		end
	  end
	}
    / 
    'listjoin' {
	  # The listjoin operator MUST have only one variable in its expansion
	  # and that variable must be a list.  If the list is non-empty then
	  # substitute the concatenation of all the list members with intevening
	  # values of arg.
      #
	  # The result of substitution MUST match the URI-reference rule and
	  # SHOULD also match any known rules for the scheme of the resulting
	  # URI.
	  def exec
        lambda do |env, joinop, vars|
          return "" unless env[vars].respond_to? :each
		  env[vars].each do |v|
		  	if env[v]
              "#{v}=#{CGI.escape(env[v])}"
		  	end
		  end.join(joinop)
		end
	  end
	}
    )
  end

  rule vars
    var ("," var)*
  end
  
  rule unreserved
    alphanumeric / '-' / '&' / '/' / ','
  end

  rule pct_encoded
    alpha+ / '%'
  end

  rule reserved
    [:/?#\[\]@!$&'()*+,;=]
  end

  rule vardefault
    (unreserved / pct_encoded)*  
  end

  rule var
    varname defaults:('=' vardefault)* {
        def value(env={} )
		  return CGI.escape(env[name]) if env[name] # CGI.escape(env[name])
		  #defaults.elements[0].text_value if defaults.elements.size > 0
		  defaults.text_value.gsub(/=/, '')
        end
        def name
		  varname.text_value
        end
    }
  end

  rule operator
    "-" op "|" arg "|" vars { 
      def value(env={})
        op.exec.call(env, arg.text_value, vars.text_value) # if op.respond_to?(:exec)
      end
    }
  end
  
  rule varname
    [a-zA-Z0-9] [a-zA-Z0-9_.-]* 
  end

  rule alpha
    [A-Za-z_]
  end

  rule alphanumeric
    alpha / [0-9]
  end

end
