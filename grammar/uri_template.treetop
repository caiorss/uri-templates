grammar UriTemplate

  rule uri_template
    uri_element more_elements:(uri_element)* {
      def value(env={})
		#raise more_elements.elements.inspect
        uri_element.value(env) << more_elements.elements.map{|el| el.value(env)}.join
      end
    }
  end
  
  rule uri_element
    expansion / uri_part
  end

  rule expansion
    '{' 
	c:(
		var
		/
		operator
	) 
	'}'
	 {
        def value(env = {})
            #c.elements.map{|el| if el.respond_to?(:value); el.value(env); else; el.interval.to_s + "<>"; end }.join
			if c.respond_to? :value
			c.value(env)
			else
			c.interval.to_s + "<>"
			end
        end
      } 
  end

  rule uri_part
    (alphanumeric+ / ':' / '/' / '.' / '?' / '&' / '=') {
          def value(env = {})
            text_value
          end
        }
  end
 
  rule arg
    (reserved / unreserved / pct_encoded)*
  end

  rule op
    (
    'opt' 
    / 
    'neg' 
    / 
    'prefix' {
      def exec
        lambda do |env, prefix, vars| 
		  if env[vars]
			val = CGI.escape(env[vars])
			val ? "#{prefix}#{val}" : ""
		  end
		end
      end
    } 
    / 
    'append' 
    / 
    'join' 
    / 
    'listjoin'
    )
  end

  rule vars
    var ("," vars)*
  end
  
  rule unreserved
    alphanumeric / '-' / '&' / '/' / ','
  end

  rule pct_encoded
    alpha+
  end

  rule reserved
    [:/?#\[\]@!$&'()*+,;=]
  end

  rule vardefault
    (unreserved / pct_encoded)*  
  end

  rule var
    varname defaults:('=' vardefault)* {
        def value(env={} )
		  CGI.escape(env[name]) if env[name] # CGI.escape(env[name])
        end
        def name
		  varname.text_value
        end
    }
  end

  rule operator
    "-" op "|" arg "|" vars { 
      def value(env={})
        op.exec.call(env, arg.text_value, vars.text_value) # if op.respond_to?(:exec)
      end
    }
  end
  
  rule varname
    [a-zA-Z0-9] [a-zA-Z0-9_.-]* 
  end

  rule alpha
    [A-Za-z_]
  end

  rule alphanumeric
    alpha / [0-9]
  end

end
